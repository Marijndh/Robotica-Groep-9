from bluedot.btcomm import BluetoothClient
from time import sleep
from .Kinematics import Kinematics


class PiClient:
    def __init__(self, link1, link2, range1, range2, publisher):
        self.link1, self.link2 = link1, link2
        self.range1, self.range2 = range1, range2
        self.max_reach = link1 + link2
        self.km = Kinematics(link1, link2, range1, range2)
        self.pos_x, self.pos_y = 372, 0
        self.ax12_range = 300
        self.offset_range1 = (self.ax12_range - self.range1 / 2)
        self.offset_range2 = (self.ax12_range - self.range2 / 2)
        self.client = None
        self.publisher = publisher

    def command(self, angle1, angle2):
        # Arm bottom id 1, arm top id 2
        self.publisher.send_command(1, self.convert_unit(angle1))
        self.publisher.send_command(2, self.convert_unit(angle2))

    def convert_unit(self, degrees):
        return round((1023 / self.ax12_range) * degrees)

    def handle_input(self, input):
        target_x = self.pos_x
        target_y = self.pos_y
        move = False

        match input:
            case "forward":
                target_x += 10
                move = True
            case "backward":
                target_x -= 10
                move = True
            case "left":
                target_y += 10
                move = True
            case "right":
                target_y -= 10
                move = True
            case "up":
                print(input)
            case "down":
                print(input)
            case "open":
                print(input)
            case "close":
                print(input)
            case "init":  # move to start position
                move = True
            case _:
                print("Invalid input")

        if self.is_within_reach(target_x, target_y):
            self.pos_x, self.pos_y = target_x, target_y
            angle1, angle2 = self.km.inverse_kinematics(target_x, target_y)
            angle1 += self.range1 + self.offset_range1
            angle2 += self.range2 + self.offset_range2
            self.command(angle1, angle2)

    def data_received(self, data):
        if data is not None and isinstance(data, str):
            self.handle_input(data)

    def is_within_reach(self, target_x, target_y):
        distance = (target_x**2 + target_y**2)**0.5

        return 50 < distance <= self.max_reach

    def start(self):
        while True:
            if self.client is None:
                print("Connecting...")
                self.client = BluetoothClient("D4:8A:FC:A4:AF:06", self.data_received)
                if self.client.connected:
                    print("Connected")
                    self.handle_input("init")
                    break
                else:
                    sleep(1000)
